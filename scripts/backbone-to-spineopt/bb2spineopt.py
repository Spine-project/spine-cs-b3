#!/usr/bin/env python  
# -*- coding:utf-8 _*-

# Author: Huang, Jiangyi <jiangyi.huang@vtt.fi>
# Created: 22:47 03/09/2020

"""
Script to build a SpineOpt model from Backbone format data on SpineDB base.

:author: J. Huang (VTT)
:date:   04.09.2020
"""

import sys
import time
from gdx2spinedb import io_config
from gdx2spinedb.import_ts import SpineDBImporter, generate_time_index

timeseries_repeat = False


def operating_time(func):
    def wrapper(*x):
        t0 = time.time()
        func_output = func(*x)
        delta_t = time.time() - t0
        print(f"time to execution: {delta_t} s")
        return func_output

    return wrapper
    # a function f with @operating_time maintain its original output


def __restore_fuel_price_map(_bb_spine_db_export: dict, _node_name: str, _alternative='Base'):
    """

    :param _bb_spine_db_export:
    :param _node_name:
    :param _alternative:
    :return: a dictionary of fuel prices with time stamps, EUR/MWh ?
    """
    _fuel_price = [
        x[3] for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'ts_priceChange', _node_name in x[1]])
    ]
    if _fuel_price:
        _fuel_price_map = _fuel_price[0]
    else:
        print(f"price for {_node_name} not found")
        return None

    _fuel_price = [{f"t{0:06d}": _fuel_price_map.get_value(f"t{0:06d}")}]
    for i in range(1, int(_fuel_price_map.indexes[-1][1:]) + 1):
        _index = f"t{i:06d}"
        _value_before = _fuel_price[i - 1][f"t{i - 1:06d}"]
        if _fuel_price_map.get_value(_index):
            _value = _value_before + _fuel_price_map.get_value(_index)
        else:
            _value = _value_before
        _fuel_price += [{_index: _value}]
    _fuel_price = {k: v for d in _fuel_price for k, v in d.items()}
    return _fuel_price


def __get_number_of_units(_bb_spine_db_export: dict, *_unit_names: str, default: int = 1) -> list:
    numbers = list()
    for _unit_name in _unit_names:
        bb_unit_count = [
            x[3] for x in _bb_spine_db_export['object_parameter_values'] if x[:3] == ('unit', _unit_name, 'unitCount')
        ]
        if not bb_unit_count:
            numbers.append(default)
        else:
            numbers += bb_unit_count
    return numbers


def dummy_unit_for_node(_spinedb_importer, _node_name: str, _unit_name: str, _direction: str,
                        _alternative='Base', **kwargs):
    """
    :param _spinedb_importer: an instance of class gdx2spinedb.import_ts.SpineDBImporter
    :param _node_name: the node that needs spill or fueling units, must be created in advance in the _spinedb_importer
    :param _unit_name: the dummy unit
    :param _direction: SpineOpt direction, "to_node" (for fueling) or "from_node" (for spill)
    :param _alternative:
    :param kwargs: parameter name and the value for relationship of the node and the dummy unit,
                   activated parameters: unit_capacity, fuel_cost, vom_cost
    :return:
    """
    if all([_direction != "from_node", _direction != "to_node"]):
        print("Wrong direction term, only 'from_node', 'to_node' and 'auto' are accepted.")
        raise

    _spinedb_importer.objects.append(("unit", _unit_name))
    _spinedb_importer.relationships.append((f"unit__{_direction}", (_unit_name, _node_name)))

    _unit_capacity = kwargs.get("unit_capacity", None)
    _fuel_cost = kwargs.get("fuel_cost", None)
    _vom_cost = kwargs.get("vom_cost", None)

    _spinedb_importer.relationship_parameter_values += [
        (f"unit__{_direction}", (_unit_name, _node_name), key, value, _alternative)
        for key, value in kwargs.items() if all([key, value])
    ]
    return _spinedb_importer


def demand_time_series(_bb_spine_db_export: dict, _grid_name: str, _node_name: str, _time_index, *alternatives,
                       _auto_alternative=True, _base_alternative: str = None, _node_rename=None
                       ):
    """
    :param _bb_spine_db_export: a export dictionary for spineDB, obtained via spineDB.export_spinedb()
    :param _grid_name:
    :param _node_name:
    :param _time_index: a pandas DatetimeIndex, which can be generated by gdx2spinedb.import_ts
    :param _auto_alternative: allow the function to search default alternatives
    :param _base_alternative: the alternative to be set as the 'Base"
    :param _node_rename:
    :param alternatives: the "fxx" to be included in the Backbone database (.gdx)
    :return:
    """
    _temp_importer = SpineDBImporter()

    if _auto_alternative:
        parameter_scenarios = [
            x for x in _bb_spine_db_export['relationship_parameter_values']
            if all([x[0] == 'ts_grid__node__f', x[1][:2] == [_grid_name, _node_name], x[2] == 'ts_influx'])
        ]
    else:
        parameter_scenarios = [
            x for x in _bb_spine_db_export['relationship_parameter_values'] for alt in alternatives
            if all([x[0] == 'ts_grid__node__f', x[1] == [_grid_name, _node_name, alt], x[2] == 'ts_influx'])
        ]
    _has_base_alternative = True
    if any([
            not _base_alternative,
            all([_base_alternative not in x[1] for x in _bb_spine_db_export['relationship_parameter_values']])
    ]):
        _has_base_alternative = False
        print(f"No alternative was specified as the Base or the alternative {_base_alternative} does not exist")

    if _node_rename:
        _node_name = _node_rename
    # grid in bb_format translated as commodity in spineopt
    # node in bb_format translated as node in spineopt
    _temp_importer.objects += [("commodity", _grid_name), ("node", _node_name)]
    # add node__commodity relationship
    _temp_importer.relationships.append(("node__commodity", (_node_name, _grid_name)))

    _time_index = [str(x) for x in _time_index]

    for alt in parameter_scenarios:
        # spinedb_api.parameter_value.Map is a list
        # the following map.values[] method is unnecessary for the value list aligning with the _time_index
        # but it provides a method to slice the data, which can be useful in the future
        __demand = [-x for x in alt[3].values[:len(_time_index)]]
        # zip(a, b) takes only the common parts between a and b aligning from the first element
        __demand = dict(zip(_time_index, __demand))
        if _has_base_alternative and _base_alternative == alt[1][2]:
            _temp_importer.object_parameter_values += [
                ("node", _node_name, "demand",
                 {"type": "time_series", "data": __demand, "index": {"repeat": timeseries_repeat}}, 'Base'),
            ]
        else:
            _temp_importer.object_parameter_values += [
                ("node", _node_name, "demand",
                 {"type": "time_series", "data": __demand, "index": {"repeat": timeseries_repeat}}, alt[1][2]),
            ]
            if (alt[1][2]) not in _temp_importer.alternatives:
                _temp_importer.alternatives.append(alt[1][2])
    return _temp_importer


def capacity_factor_time_series(_bb_spine_db_export: dict, _flow_name: str, _node_name: str, _grid_name: str,
                                _time_index, *alternatives,
                                _auto_alternative=True, _base_alternative: str = None, _mode="node",
                                ):
    """
    :param _bb_spine_db_export: a export dictionary for spineDB, obtained via gdx2spinedb.spinedb.export_spinedb()
    :param _flow_name:
    :param _node_name:
    :param _grid_name: the grid to which the capacity factor belongs
    :param _time_index: pandas DatetimeIndex, which can be generated by gdx2spinedb.import_ts
    :param _time_index: pandas DatetimeIndex, which can be generated by gdx2spinedb.import_ts
    :param alternatives:
    :param _base_alternative:
    :param _auto_alternative:
    :param _mode: str,
            "node" to model the capacity factor (CF) as source node demand derived from multiplying with unit capacity;
            "unit" to model the CF as such via parameter "unit_conv_cap_to_flow" w.r.t. an artificial source node.
    :return:
    """
    _temp_importer = SpineDBImporter()

    # from BB_gdx ts_cf (SpineDB ts_flow__node__f)
    if _auto_alternative:
        parameter_scenarios = [
            x for x in _bb_spine_db_export['relationship_parameter_values']
            if all([x[0] == 'ts_flow__node__f', _flow_name in x[1], _node_name in x[1], x[2] == 'ts_cf'])
        ]
    else:
        parameter_scenarios = [
            x for x in _bb_spine_db_export['relationship_parameter_values'] for alt in alternatives
            if all([x[0] == 'ts_flow__node__f', x[1] == [_flow_name, _node_name, alt], x[2] == 'ts_cf'])
        ]
    _has_base_alternative = True
    if any([
            not _base_alternative,
            all([_base_alternative not in x[1] for x in _bb_spine_db_export['relationship_parameter_values']])
    ]):
        _has_base_alternative = False
        print(f"No alternative was specified as the Base or the alternative {_base_alternative} does not exist")

    _time_index = [str(x) for x in _time_index]

    # inconsistent terms for wind: 'Wind' for flow and unit names in main database, 'wind' for ts_cf in forecast
    _flow_name_for_units = _flow_name
    if _flow_name == 'wind':
        _flow_name_for_units = 'Wind'

    # find the corresponding units as per BB_gdx flowUnit (SpineDB flow__unit)
    # can be multiple units to one flow, e.g. units 75FI_PV and 75FI_PV2 to the same PV flow
    _unit_names = list(
        set([x[1][1] for x in _bb_spine_db_export['relationships'] if
             all([x[0] == 'flow__unit', _flow_name_for_units in x[1]])])
        &
        set([x[1][2] for x in _bb_spine_db_export['relationships']
             if all([x[0] == 'grid__node__unit__io', x[1][:2] == [_grid_name, _node_name]])])
    )

    if _mode == "node":
        # flow in bb_format translated as commodity in spineopt
        _temp_importer.objects.append(("commodity", _flow_name))

        # Aggregated capacity from bb_gdx
        _capacity_values = list(
            map(
                lambda _unit_name:
                [x[3] for x in _bb_spine_db_export['relationship_parameter_values']
                 if all([x[0] == 'grid__node__unit__io', x[1][:3] == [_grid_name, _node_name, _unit_name],
                         x[2] == 'capacity'])],
                _unit_names
            )
        )
        _number_of_units = __get_number_of_units(_bb_spine_db_export, *_unit_names, default=1)
        _unit__capacity = dict(zip(_unit_names, list(zip(_capacity_values, _number_of_units))))

        # create relationship and its value for flows from source to the unit
        # use unit_constraint approach
        for _unit_name in _unit_names:
            # create a name for the unit_constraint
            _unit_constraint_name = f"Eff_{_unit_name}"
            # create an additional node for source
            _source_node_name = f"source_{_unit_name}"
            _temp_importer.objects += [
                ("unit_constraint", _unit_constraint_name),
                ("node", _source_node_name),
            ]
            _temp_importer.relationships += [
                ("node__commodity", (_source_node_name, _flow_name)),
                ("unit__unit_constraint", (_unit_name, _unit_constraint_name)),
                ("unit__from_node", (_unit_name, _source_node_name)),
                ("unit__from_node__unit_constraint", (_unit_name, _source_node_name, _unit_constraint_name)),
            ]
            _temp_importer.relationship_parameter_values += [
                ("unit__from_node__unit_constraint", (_unit_name, _source_node_name, _unit_constraint_name),
                 "unit_flow_coefficient", 1.0, 'Base'),
            ]
            for i, alt in enumerate(parameter_scenarios):
                __capacity_factor = [x if abs(x) > 10e-300 else 0 for x in alt[3].values[:len(_time_index)]]
                __source_flow = [-x * _unit__capacity[_unit_name][0][i] for x in __capacity_factor]
                __source_flow = dict(zip(_time_index, __source_flow))
                if _has_base_alternative and _base_alternative == alt[1][2]:
                    _temp_importer.object_parameter_values += [
                        (
                            "node", _source_node_name, "demand",
                            {"type": "time_series", "data": __source_flow, "index": {"repeat": timeseries_repeat}},
                            'Base'
                        ),
                    ]
                else:
                    _temp_importer.object_parameter_values += [
                        (
                            "node", _source_node_name, "demand",
                            {"type": "time_series", "data": __source_flow, "index": {"repeat": timeseries_repeat}},
                            alt[1][2]
                        ),
                    ]
                    if (alt[1][2]) not in _temp_importer.alternatives:
                        _temp_importer.alternatives.append(alt[1][2])
    if _mode == "unit":
        for _unit_name in _unit_names:
            _direction = [
                "to_node" if x[1][3] == "output" else "from_node"
                for x in _bb_spine_db_export['relationships']
                if all([x[0] == 'grid__node__unit__io', x[1][:3] == [_grid_name, _node_name, _unit_name]])
            ][0]
            # create an artificial source node with a dummy inflow unit
            if _direction == "from_node":
                _source_node_name = f"source_{_unit_name}"
                _node_name = _source_node_name
                _temp_importer = dummy_unit_for_node(
                    _temp_importer, _source_node_name, f"Inflow_{_source_node_name}", "to_node"
                )
            _temp_importer.relationships.append((f"unit__{_direction}", (_unit_name, _node_name)))
            for alt in parameter_scenarios:
                __capacity_factor = [x if abs(x) > 10e-300 else 0 for x in alt[3].values[:len(_time_index)]]
                __capacity_factor = dict(zip(_time_index, __capacity_factor))
                if _has_base_alternative and _base_alternative == alt[1][2]:
                    _temp_importer.relationship_parameter_values += [
                        (
                            f"unit__{_direction}", [_unit_name, _node_name], "unit_conv_cap_to_flow",
                            {"type": "time_series", "data": __capacity_factor, "index": {"repeat": timeseries_repeat}},
                            'Base'
                        ),
                    ]
                else:
                    _temp_importer.relationship_parameter_values += [
                        (
                            f"unit__{_direction}", [_unit_name, _node_name], "unit_conv_cap_to_flow",
                            {"type": "time_series", "data": __capacity_factor, "index": {"repeat": timeseries_repeat}},
                            alt[1][2]
                        ),
                    ]
    return _temp_importer


def unit_parameters(_bb_spine_db_export: dict, _grid_name: str, _node_name: str, _unit_name: str, _time_index,
                    _alternative='Base', _eff_level=1, _p_unit=False,
                    _node_name_if_output=None, _node_name_if_input=None
                    ):
    """
    :param _bb_spine_db_export:
    :param _grid_name:
    :param _node_name: name used to search in _bb_spine_db_export
    :param _unit_name:
    :param _time_index: used only for time-variant fuel prices
    :param _alternative:
    :param _eff_level: default efficiency level for units without effLevelGroupUnit definition,
           should be set to the highest level in practice
    :param _p_unit: default Fault, True to enable parsing unit specific values from p_unit
    :param _node_name_if_output: str, set a new name for the sought node (_node_name) if the unit outputs to it
    :param _node_name_if_input: str, set a new name for the sought node (_node_name) if the unit receives its input
    :return:
    """
    _temp_importer = SpineDBImporter()

    # Parameters 1: from BB_gdx p_gnu_io (SpineDB grid__node__unit__io)
    _parameters_1 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'grid__node__unit__io', x[1][:3] == [_grid_name, _node_name, _unit_name]])
    ]
    _fuel_commodity = [
        x[1][0] for x in _bb_spine_db_export['relationships'] if x[0] == 'commodity'
    ]
    _unit_capacity = 0

    # Parameters 2: from BB_gdx effLevelGroupUnit (SpineDB efflevel__group__unit)
    # unit_online_type
    _parameters_2 = [
        x for x in _bb_spine_db_export['relationships']
        if all([x[0] == 'efflevel__group__unit', _unit_name in x[1]])
    ]

    # Parameters 3: from BB_gdx p_unit (SpineDB unit)
    _parameters_3 = [
        x for x in _bb_spine_db_export['object_parameter_values']
        if all([x[0] == 'unit', x[1] == _unit_name])
    ]

    # Translate Parameter 1
    # TODO: other bb parameter under the category p_gnu_io, unitSize for investment
    for par in _parameters_1:
        if par[1][3] == 'output':
            if _node_name_if_output:
                _node_name = _node_name_if_output
            # add unit__to_node relationship for output
            _temp_importer.relationships.append(("unit__to_node", (_unit_name, _node_name)))

            if par[2] == 'capacity':
                # capacity is aggregated in Backbone but SpineOpt requires unit capacity
                _number_of_units = __get_number_of_units(_bb_spine_db_export, _unit_name, default=1)
                _unit_capacity = par[3] / _number_of_units[0]
                _temp_importer.relationship_parameter_values += [
                    ("unit__to_node", [_unit_name, _node_name], "unit_capacity", _unit_capacity, _alternative),
                ]
            elif par[2] == 'conversionCoeff':
                _temp_importer.relationship_parameter_values += [
                    ("unit__to_node", [_unit_name, _node_name], "unit_conv_cap_to_flow", par[3], _alternative),
                ]
            elif par[2] == 'vomCosts':
                _temp_importer.relationship_parameter_values += [
                    ("unit__to_node", [_unit_name, _node_name], "vom_cost", par[3], _alternative),
                ]
        elif par[1][3] == 'input':
            if _node_name_if_input:
                _node_name = _node_name_if_input
            # add unit__from_node relationship for input
            _temp_importer.relationships.append(("unit__from_node", (_unit_name, _node_name)))
            # build parameters
            if par[2] == 'capacity':
                # capacity is aggregated in Backbone but SpineOpt requires unit capacity
                _number_of_units = __get_number_of_units(_bb_spine_db_export, _unit_name, default=1)
                _unit_capacity = par[3] / _number_of_units[0]
                _temp_importer.relationship_parameter_values += [
                    ("unit__from_node", [_unit_name, _node_name], "unit_capacity", _unit_capacity, _alternative),
                ]
            elif par[2] == 'conversionCoeff':
                _temp_importer.relationship_parameter_values += [
                    ("unit__from_node", [_unit_name, _node_name], "unit_conv_cap_to_flow", par[3], _alternative),
                ]
            elif par[2] == 'vomCosts':
                _temp_importer.relationship_parameter_values += [
                    ("unit__from_node", [_unit_name, _node_name], "vom_cost", par[3], _alternative),
                ]

            # For nodes which are created to supply fuels
            if _node_name in _fuel_commodity:
                # add an additional dummy unit to balance the input node that is particularly for fuel source
                _temp_importer = dummy_unit_for_node(
                    _temp_importer, _node_name, f"Fueling_unit_{_node_name}", "to_node"
                )

                # build fuel price, in either TimeSeries or constant value
                _fuel_price_dict = __restore_fuel_price_map(_bb_spine_db_export, _node_name, _alternative=_alternative)
                if len(_fuel_price_dict) != 1:
                    __time_index = [str(x) for x in _time_index]
                    _fuel_price_ts = dict(zip(__time_index, list(_fuel_price_dict.values())[:len(__time_index)]))
                    _temp_importer.relationship_parameter_values += [
                        (
                            "unit__from_node", [_unit_name, _node_name], "fuel_cost",
                            {"type": "time_series", "data": _fuel_price_ts, "index": {"repeat": timeseries_repeat}},
                            _alternative
                        ),
                    ]
                # constant value
                else:
                    _fuel_price = list(_fuel_price_dict.values())[0]
                    _temp_importer.relationship_parameter_values += [
                        ("unit__from_node", [_unit_name, _node_name], "fuel_cost", _fuel_price, _alternative),
                    ]
    # grid in bb_format translated as commodity in spineopt
    # node in bb_format translated as node in spineopt
    # unit in bb_format translated as unit in spineopt
    _temp_importer.objects += [("commodity", _grid_name), ("node", _node_name), ("unit", _unit_name)]
    # add node__commodity relationship
    _temp_importer.relationships.append(("node__commodity", (_node_name, _grid_name)))
    # Translate Parameters 2
    if _parameters_2:
        # TODO: level?, lambda eff type?
        _unit_on = _parameters_2['level1' in _parameters_2]
        if _unit_on[1][1] == 'directOnMIP':
            _temp_importer.object_parameter_values.append(
                ("unit", _unit_name, "online_variable_type", "unit_online_variable_type_integer", _alternative),
            )
        elif _unit_on[1][1] == 'directOnLP':
            _temp_importer.object_parameter_values.append(
                ("unit", _unit_name, "online_variable_type", "unit_online_variable_type_linear", _alternative),
            )
        elif _unit_on[1][1] == 'directOff':
            _number_of_units = __get_number_of_units(_bb_spine_db_export, _unit_name, default=1)
            _temp_importer.object_parameter_values.append(
                ("unit", _unit_name, "fix_units_on", _number_of_units[0], _alternative),
            )

    # Translate Parameters 3
    _operating_points = [0]
    _min_operating_point = _operating_points[0]
    # for units with efficiency levels
    if _parameters_2:
        _eff_level = len(_parameters_2)
    _direction = set([x[1][3] for x in _parameters_1])
    # TODO: what about the units with _direction containing both input and output?
    _constraint_name = f"Eff_{_unit_name}"
    if 'output' in _direction and len(_direction) == 1:
        if ("unit_constraint", _constraint_name) not in _temp_importer.objects:
            _temp_importer.objects += [("unit_constraint", _constraint_name), ]
            # specify constraint settings
            _temp_importer.object_parameter_values += [
                ("unit_constraint", _constraint_name, "constraint_sense", "==", _alternative),
                ("unit_constraint", _constraint_name, "right_hand_side", 0.0, _alternative),
            ]

        _temp_importer.relationships += [
            ("unit__unit_constraint", (_unit_name, _constraint_name)),
            ("unit__to_node__unit_constraint", (_unit_name, _node_name, _constraint_name)),
        ]

        # data for units with constant efficiency is stored in the highest effLevel
        if all(['directOff' in x[1] for x in _parameters_2]):
            _max_level = max(range(0, _eff_level))
            _operating_points = [x[3] for x in _parameters_3 if x[2] == f"op{_max_level:02d}"]
            # eff = output/input
            _unit_flow_coefficient = [-(x[3] ** -1) for x in _parameters_3 if x[2] == f"eff{_max_level:02d}"]
        else:
            _operating_points = list(
                map(lambda i: [x[3] for x in _parameters_3 if x[2] == f"op{i:02d}"][0],
                    range(0, _eff_level))
            )
            # TODO: to be confirmed
            _min_operating_point = _operating_points[0]
            # eff = output/input
            _unit_flow_coefficient = list(
                map(lambda i: [-(x[3] ** -1) for x in _parameters_3 if x[2] == f"eff{i:02d}"][0],
                    range(0, _eff_level))
            )
        _temp_importer.relationship_parameter_values += [
            ("unit__to_node", (_unit_name, _node_name),
             "operating_points", {"type": "array", "value_type": "float", "data": _operating_points}, _alternative),
            ("unit__to_node", (_unit_name, _node_name),
             "minimum_operating_point", _min_operating_point, _alternative),
            ("unit__to_node__unit_constraint", (_unit_name, _node_name, _constraint_name),
             "unit_flow_coefficient", {"type": "array", "value_type": "float", "data": _unit_flow_coefficient},
             _alternative)
        ]
    elif 'input' in _direction and len(_direction) == 1:
        if ("unit_constraint", _constraint_name) not in _temp_importer.objects:
            _temp_importer.objects += [("unit_constraint", _constraint_name), ]
            # specify constraint settings
            _temp_importer.object_parameter_values += [
                ("unit_constraint", _constraint_name, "constraint_sense", "==", _alternative),
                ("unit_constraint", _constraint_name, "right_hand_side", 0.0, _alternative),
            ]

        _temp_importer.relationships += [
            ("unit__unit_constraint", (_unit_name, _constraint_name)),
            ("unit__from_node__unit_constraint", (_unit_name, _node_name, _constraint_name)),
        ]
        _unit_flow_coefficient = [
            x[3] for x in _parameters_1 if all([x[2] == "conversionCoeff"])
        ][0]
        _temp_importer.relationship_parameter_values += [
            ("unit__from_node__unit_constraint", (_unit_name, _node_name, _constraint_name),
             "unit_flow_coefficient", _unit_flow_coefficient, _alternative),
        ]

    # Whether to parse unit specific values from p_unit
    if _p_unit:
        # parameters directly translatable
        def _rename_unit_para(obj_para_value_entity: tuple, _target_para_name: str, __alternative: str):
            _para = list(obj_para_value_entity)
            _para[2] = _target_para_name
            _para[4] = __alternative
            return _para

        for par in _parameters_3:
            if par[2] == 'availability':
                _parameter = _rename_unit_para(par, "unit_availability_factor", _alternative)
                _temp_importer.object_parameter_values.append(tuple(_parameter))
            elif par[2] == 'minOperationHours':
                _parameter = _rename_unit_para(par, "min_up_time", _alternative)
                _parameter[3] = {"type": "duration", "data": f"{int(_parameter[3])}h"}
                _temp_importer.object_parameter_values.append(tuple(_parameter))
            elif par[2] == 'minShutdownHours':
                _parameter = _rename_unit_para(par, "min_down_time", _alternative)
                _parameter[3] = {"type": "duration", "data": f"{int(_parameter[3])}h"}
                _temp_importer.object_parameter_values.append(tuple(_parameter))
            # number of units, 1 is default value defined in SpineOpt database template
            elif par[2] == 'unitCount':
                _parameter = _rename_unit_para(par, "number_of_units", _alternative)
                _temp_importer.object_parameter_values.append(tuple(_parameter))
            # EUR/start/unit, start per unit capacity
            elif par[2] == 'startCostCold':
                _start_up_cost = par[3] * _unit_capacity
                _temp_importer.object_parameter_values.append(
                    ("unit", _unit_name, "start_up_cost", _start_up_cost, _alternative)
                )
            elif par[2] == 'startFuelConsCold':
                # MWh fuel/unit startup
                _start_up_fuel_consumption = - par[3] * _unit_capacity
                # Parameters 4: from BB_gdx p_uStartupfuel (SpineDB unit__startupFuel)
                _parameters_4 = [
                    x for x in _bb_spine_db_export['relationship_parameter_values']
                    if all([x[0] == 'unit__startupFuel', _unit_name in x[1]])
                ]
                if _parameters_4:
                    # the corresponding fuel node for te startup fuel
                    _start_up_fuel = _parameters_4[0][1][1]
                    # explicit startup fuel node for clarity
                    _startup_fuel_node = f"{_start_up_fuel}_for_unit_startup"
                    # _startup_fuel_node links to the same fueling unit as the fuel node
                    if ("node", _startup_fuel_node) not in _temp_importer.objects:
                        _temp_importer.objects.append(("node", _startup_fuel_node))
                        _temp_importer = dummy_unit_for_node(
                            _temp_importer, _startup_fuel_node, f"Fueling_unit_{_start_up_fuel}", "to_node"
                        )

                    # add commodity for the fuel node if there is any
                    # _startup_fuel_node shares the same commodity with the fuel node
                    _grid_for_fuel_commodity = [
                        x[1][0] for x in _bb_spine_db_export['relationships']
                        if all([x[0] == 'grid__node', _start_up_fuel in x[1]])
                    ]
                    if _grid_for_fuel_commodity:
                        _fuel_commodity = _grid_for_fuel_commodity[0]
                        if ("commodity", _fuel_commodity) not in _temp_importer.objects:
                            _temp_importer.objects.append(("commodity", _fuel_commodity))
                            _temp_importer.relationships += [
                                ("node__commodity", (_startup_fuel_node, _fuel_commodity)),
                            ]
                    else:
                        print(f"The corresponding grid for fuel node {_start_up_fuel} is missing.")

                    # build unit_constraint for startup fuel flow
                    _constraint_name = f"Startup_fuel_{_unit_name}"
                    _temp_importer.objects += [
                        ("unit_constraint", _constraint_name),
                    ]
                    _temp_importer.relationships += [
                        ("unit__from_node", (_unit_name, _startup_fuel_node)),
                        ("unit__unit_constraint", (_unit_name, _constraint_name)),
                        ("unit__from_node__unit_constraint", (_unit_name, _startup_fuel_node, _constraint_name)),
                    ]
                    _temp_importer.object_parameter_values += [
                        ("unit_constraint", _constraint_name, "constraint_sense", "==", _alternative),
                        ("unit_constraint", _constraint_name, "right_hand_side", 0.0, _alternative),
                    ]
                    _temp_importer.relationship_parameter_values += [
                        ("unit__unit_constraint", (_unit_name, _constraint_name),
                         "units_started_up_coefficient", _start_up_fuel_consumption, _alternative),
                        ("unit__from_node__unit_constraint", (_unit_name, _startup_fuel_node, _constraint_name),
                         "unit_flow_coefficient", 1.0, _alternative),
                    ]

                    # build fuel price, in either TimeSeries or constant value, if there is any
                    _fuel_price_dict = __restore_fuel_price_map(
                        _bb_spine_db_export, _start_up_fuel, _alternative=_alternative
                    )
                    if len(_fuel_price_dict) != 1:
                        __time_index = [str(x) for x in _time_index]
                        _fuel_price_ts = dict(
                            zip(__time_index, list(_fuel_price_dict.values())[:len(__time_index)]))
                        _temp_importer.relationship_parameter_values += [
                            ("unit__from_node", [_unit_name, _startup_fuel_node], "fuel_cost",
                             {"type": "time_series", "data": _fuel_price_ts, "index": {"repeat": timeseries_repeat}},
                             _alternative),
                        ]
                    # constant value
                    else:
                        _fuel_price = list(_fuel_price_dict.values())[0]
                        _temp_importer.relationship_parameter_values += [
                            ("unit__from_node", [_unit_name, _startup_fuel_node], "fuel_cost", _fuel_price,
                             _alternative),
                        ]
    # set default number_of_units and unit_availability_factor to 1.0 if not explicitly recorded in the database
    # else:
    #     _temp_importer.object_parameter_values += [
    #         ("unit", _unit_name, "unit_availability_factor", 1.0, _alternative),
    #         ("unit", _unit_name, "number_of_units", 1.0, _alternative),
    #     ]

    return _temp_importer


def node_parameters(
        _bb_spine_db_export: dict, _grid_name: str, _node_name: str, _time_index, _alternative='Base', _node_rename=None
):
    _temp_importer = SpineDBImporter()

    # Parameters 1: from BB_gdx p_gn (SpineDB grid__node)
    _parameters_1 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'grid__node', x[1] == [_grid_name, _node_name]])
    ]
    # Parameters 2: from BB_gdx p_gnBoundaryPropertiesForStates (SpineDB grid__node__boundary)
    _parameters_2 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'grid__node__boundary', x[1][:2] == [_grid_name, _node_name]])
    ]

    _time_index = [str(x) for x in _time_index]

    if _node_rename:
        _node_name = _node_rename
    # grid in bb_format translated as commodity in spineopt
    # node in bb_format translated as node in spineopt
    _temp_importer.objects += [("commodity", _grid_name), ("node", _node_name)]
    # add node__commodity relationship
    _temp_importer.relationships.append(("node__commodity", (_node_name, _grid_name)))
    for par in _parameters_1:
        if par[2] == 'nodeBalance' and par[3] == 1:
            _temp_importer.object_parameter_values += [
                ("node", _node_name, "balance_type", "balance_type_node", _alternative),
            ]
        elif par[2] == 'selfDischargeLoss':
            _temp_importer.object_parameter_values += [
                ("node", _node_name, "frac_state_loss", par[3], _alternative),
            ]
        # the value of reference serves as a bound to the node state at the first time step
        elif par[2] == 'boundStart':
            # a sample of parameter reference (in constant value only)
            _reference_state = [{x[2]: x[3]} for x in _parameters_2 if x[1][2] == 'reference']
            _reference_state = {k: v for d in _reference_state for k, v in d.items()}
            # TODO: useTimeSeries, multiplier?
            if all(['constant' in _reference_state.keys(), 'useConstant' in _reference_state.keys()]) \
                    and _reference_state['constant'] * _reference_state['useConstant'] > 10e-300:
                _reference_state = {_time_index[0]: _reference_state['constant']}
                _temp_importer.object_parameter_values.append(
                    (
                        "node", _node_name, "fix_node_state",
                        {"type": "time_series", "data": _reference_state, "index": {"repeat": timeseries_repeat}},
                        _alternative
                    )
                )
        # TODO: other parameters, e.g. energyStoredPerUnitOfState?

    # node storage if there is any
    _state_cap = [{x[2]: x[3]} for x in _parameters_2 if x[1][2] == 'upwardLimit']
    _state_cap = {k: v for d in _state_cap for k, v in d.items()}
    # TODO: useTimeSeries, multiplier?
    if all(['constant' in _state_cap.keys(), 'useConstant' in _state_cap.keys()]) \
            and _state_cap['constant'] * _state_cap['useConstant'] > 10e-300:
        _state_cap = _state_cap['constant']
        _temp_importer.object_parameter_values += [
            ("node", _node_name, "node_state_cap", _state_cap, _alternative),
            # node with node_state_cap should enable has_state and state_coeff
            ("node", _node_name, "has_state", True, _alternative),
            ("node", _node_name, "state_coeff", 1.0, _alternative),
        ]
        _state_min = [{x[2]: x[3]} for x in _parameters_2 if x[1][2] == 'downwardLimit']
        _state_min = {k: v for d in _state_min for k, v in d.items()}
        if all(['constant' in _state_min.keys(), 'useConstant' in _state_min.keys()]):
            if _state_min['constant'] * _state_min['useConstant'] > 10e-300:
                _state_min = _state_min['constant']
            else:
                _state_min = 0
            _temp_importer.object_parameter_values += [
                ("node", _node_name, "node_state_min", _state_min, _alternative),
            ]

    # model node spill if there is any
    _max_spill = [x[3] for x in _parameters_2 if all(['maxSpill' in x[1], x[2] == 'constant'])]
    if _max_spill:
        _max_spill = _max_spill[0]
        _spill_unit_name = f"Spill_{_node_name}"
        _temp_importer = dummy_unit_for_node(
            _temp_importer, _node_name, _spill_unit_name, "from_node", unit_capacity=_max_spill
        )

    return _temp_importer


def unit_bi_inputs_outputs(_bb_spine_db_export: dict, _unit_name: str, _node_name_1: str, _node_name_2: str,
                           _direction="auto", _alternative='Base', _create_structure=True):
    """
    For units which generate two energy outputs or consume two inputs, e.g. CHPs
    two approaches are feasible in SpineOpt: 1) unit_constraint, 2) unit_node_node
    this function uses approach 1)
    Note: All relevant entities (objects and relationship) can be created (optional).
          Only the parameter values specific to control the bi-output flows of the unit are written.
          To import other parameter values of unit, node and corresponding relationships, use unit_parameters().
    :param _bb_spine_db_export:
    :param _unit_name:
    :param _node_name_1:
    :param _node_name_2:
    :param _direction: "auto", "from_node", "to_node"
    :param _alternative:
    :param _create_structure: True if to create relevant entities (objects and relationship)
    :return:
    """
    _temp_importer = SpineDBImporter()

    # Parameters 1: from BB_gdx p_unitConstraint (SpineDB unit__constraint)
    _parameters_1 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'unit__constraint', _unit_name in x[1]])
    ]
    # Parameters 2: from BB_gdx p_unitConstraintNode (SpineDB unit__constraint__node)
    _parameters_2 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all(
            [x[0] == 'unit__constraint__node', _unit_name in x[1], any([_node_name_1 in x[1], _node_name_2 in x[1]])]
        )
    ]

    # check the consistency of flow directions
    if _direction == "auto":
        _direction = set([
            x[1][3] for x in _bb_spine_db_export['relationship_parameter_values']
            if all(
                [x[0] == 'grid__node__unit__io',
                 _unit_name in x[1],
                 any([_node_name_1 in x[1], _node_name_2 in x[1]])]
            )])
        if _direction == {"input", "output"}:
            print("Directions between the unit to the two specified nodes are inconsistent.\n"
                  "Check the source data or claim explicitly the SpineOpt directions as 'from_node' or 'to_node'.")
            raise
        elif _direction == {"input"}:
            _direction = "from_node"
        elif _direction == {"output"}:
            _direction = "to_node"
    elif all([_direction != "from_node", _direction != "to_node"]):
        print("Wrong direction term, only 'from_node', 'to_node' and 'auto' are accepted.")
        raise

    _constraint_prefix = "unspecified"
    if _direction == "to_node":
        _constraint_prefix = "outputs"
    elif _direction == "from_node":
        _constraint_prefix = "inputs"

    # create background structure
    if _create_structure:
        _temp_importer.objects += [
            ("unit", _unit_name),
            ("node", _node_name_1),
            ("node", _node_name_2),
        ]
        _temp_importer.relationships += [
            (f"unit__{_direction}", (_unit_name, _node_name_1)),
            (f"unit__{_direction}", (_unit_name, _node_name_2)),
        ]

    # refine the sense of constraints in parameters 1

    _parameters_1 = [
        x for x in _parameters_1
        if tuple(x[1]) in set([tuple(y[1][:2]) for y in _parameters_2])
    ]

    for par_1 in _parameters_1:
        _constraint_name = f"Ratio_between_{_constraint_prefix}_{_unit_name}_{par_1[1][1]}"
        _temp_importer.objects.append(("unit_constraint", _constraint_name))
        _temp_importer.relationships += [
            ("unit__unit_constraint", (_unit_name, _constraint_name)),
            (f"unit__{_direction}__unit_constraint", (_unit_name, _node_name_1, _constraint_name)),
            (f"unit__{_direction}__unit_constraint", (_unit_name, _node_name_2, _constraint_name)),
        ]

        _rhs_constraint = par_1[3]
        if abs(_rhs_constraint) < 10e-300:
            _rhs_constraint = 0
        # the constraint formula is by default an equation
        _constraint_sense = "=="
        if 'eq' in par_1[1][1]:
            _constraint_sense = "=="
        elif 'gt' in par_1[1][1]:
            _constraint_sense = ">="

        _temp_importer.object_parameter_values += [
            ("unit_constraint", _constraint_name, "constraint_sense", _constraint_sense, _alternative),
            ("unit_constraint", _constraint_name, "right_hand_side", _rhs_constraint, _alternative),
        ]

        for par_2 in _parameters_2:
            if all([par_1[1] == par_2[1][:2], any([_node_name_1 in par_2[1], _node_name_2 in par_2[1]])]):
                _temp_importer.relationship_parameter_values += [
                    (f"unit__{_direction}__unit_constraint", (par_2[1][0], par_2[1][2], _constraint_name),
                     "unit_flow_coefficient", par_2[3], _alternative),
                ]

    return _temp_importer


def unit_emissions(_bb_spine_db_export: dict,
                   _grid_name: str, _demand_node_name: str, _fuel_node_name: str, _unit_name: str,
                   _emission_name='CO2', _alternative='Base', _create_structure=True):
    """
    Assumption: emission is regional and counted on demand nodes with master commodity flow, e.g. electricity
    two approaches are feasible in SpineOpt: 1) unit_constraint, 2) unit_node_node
    this function uses approach 1)
    Note: Closest relevant entities (objects and relationship) can be created (optional).
          Only the emission relevant parameter values of the unit are written.
          To import other parameter values of unit, node and corresponding relationships,
          use unit_parameters() and node_parameters().
          the grid_name and _demand_node_name specified are simply to define a region to which the emission belongs
    :param _bb_spine_db_export:
    :param _grid_name: the grid of master node (with principal demand), only to specify corresponding emission tax
    :param _demand_node_name: the node with principal demand
    :param _fuel_node_name: the node of fuel which contains emission content
    :param _emission_name: emission name per Backbone database (.gdx)
    :param _alternative:
    :param _create_structure: True if to create relevant entities (objects and relationship)
    :param _unit_name: name for the unit that has the specified emission
    :return:
    """
    _temp_importer = SpineDBImporter()

    # Parameters 1: from BB_gdx p_gnPolicy (SpineDB grid__node__policy__emission)
    _parameters_1 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'grid__node__policy__emission', x[1][:2] == [_grid_name, _demand_node_name]])
    ]
    # e.g. emissionTax, EUR/tonne
    _emission_policy = 0
    if _parameters_1:
        _emission_policy = _parameters_1[0][3]

    # Parameters 2: from BB_gdx p_nEmission (SpineDB node__emission)
    _parameters_2 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'node__emission', x[1] == [_fuel_node_name, _emission_name]])
    ]
    # kg/MWh to tonne/MWh
    _emission_factor = 0
    if _parameters_2:
        _emission_factor = _parameters_2[0][3] / 1000

    # create background structure
    if _create_structure:
        _temp_importer.objects += [
            ("unit", _unit_name),
            ("node", _fuel_node_name),
        ]
        _temp_importer.relationships.append((f"unit__from_node", (_unit_name, _fuel_node_name)))

    # create emission sink node and the affiliated dummy unit based on the principal demand node
    _sink_node_name = f"sink_{_emission_name}_{_demand_node_name}"
    _sink_unit_name = f"Emission_{_emission_name}_absorber"
    _temp_importer.objects += [
        ("node", _sink_node_name),
        ("commodity", f"Emission_{_emission_name}"),
    ]
    _temp_importer.relationships.append((f"node__commodity", (_sink_node_name, f"Emission_{_emission_name}")))
    # emission tax on gross emission of the master demand node
    # using parameter "tax_in_unit_flow" is the same since the sum of inflow equals the outflow
    _temp_importer.object_parameter_values.append(
        ("node", _sink_node_name, "tax_out_unit_flow", _emission_policy, _alternative)
    )
    _temp_importer = dummy_unit_for_node(_temp_importer, _sink_node_name, _sink_unit_name, "from_node")
    # create unit_constraint for the emission of the unit
    _constraint_name = f"Emission_{_emission_name}_{_unit_name}"
    _temp_importer.objects.append(("unit_constraint", _constraint_name))
    # specify constraint settings
    _temp_importer.object_parameter_values += [
        ("unit_constraint", _constraint_name, "constraint_sense", "==", _alternative),
        ("unit_constraint", _constraint_name, "right_hand_side", 0.0, _alternative),
    ]
    # create relationships related to the unit emission
    _temp_importer.relationships += [
        ("unit__unit_constraint", (_unit_name, _constraint_name)),
        ("unit__to_node", (_unit_name, _sink_node_name)),
        ("unit__to_node__unit_constraint", (_unit_name, _sink_node_name, _constraint_name)),
        ("unit__from_node__unit_constraint", (_unit_name, _fuel_node_name, _constraint_name)),
    ]
    # emission factor based on fuel
    _temp_importer.relationship_parameter_values += [
        (f"unit__to_node__unit_constraint", (_unit_name, _sink_node_name, _constraint_name),
         "unit_flow_coefficient", -1.0, _alternative),
        (f"unit__from_node__unit_constraint", (_unit_name, _fuel_node_name, _constraint_name),
         "unit_flow_coefficient", _emission_factor, _alternative),
    ]

    return _temp_importer


def connection_for_node(_bb_spine_db_export: dict, _grid_name: str, _node_name_1: str, _node_name_2: str,
                        _alternative='Base', _create_structure=True):
    """
    Note: for connection to external nodes, e.g. export and import, add dummy units using dummy_unit_for_node()
          the order of node_name_1 and node_name_2 is irrelevant, the function searches all occurrences
    :param _bb_spine_db_export:
    :param _grid_name:
    :param _node_name_1:
    :param _node_name_2:
    :param _alternative:
    :param _create_structure:
    :return:
    """
    _temp_importer = SpineDBImporter()

    # Parameters 1: from BB_gdx p_gnn (SpineDB grid__node__node)
    _parameters_1 = [
        x for x in _bb_spine_db_export['relationship_parameter_values']
        if all([x[0] == 'grid__node__node', _grid_name in x[1], _node_name_1 in x[1], _node_name_2 in x[1]])
    ]

    # create background structure
    if _create_structure:
        _temp_importer.objects += [
            ("node", _node_name_1),
            ("node", _node_name_2),
        ]

    _nodes = sorted([_node_name_1, _node_name_2])
    _connection_name = "--".join(_nodes)
    _temp_importer.objects.append(("connection", _connection_name))

    for par in _parameters_1:
        # set up a connection__node__node relationship with ratio_out_in being 1.0 as default
        if ("connection__node__node", [_connection_name] + par[1][1:]) not in _temp_importer.relationships:
            _obj_list = [_connection_name] + par[1][1:]
            _temp_importer.relationships.append(("connection__node__node", [_connection_name] + par[1][1:]))
            _temp_importer.relationship_parameter_values.append(
                ("connection__node__node", _obj_list, "fix_ratio_out_in_connection_flow", 1.0, _alternative)
            )
        # overwrite the default ratio_out_in if there is any value specified in the source database
        if par[2] == 'transferLoss':
            _obj_list = [_connection_name] + par[1][1:]
            # remove the created duplicate parameter value
            _temp_importer.relationship_parameter_values = [
                x for x in _temp_importer.relationship_parameter_values
                if x != ("connection__node__node", _obj_list, "fix_ratio_out_in_connection_flow", 1.0, _alternative)
            ]
            _temp_importer.relationship_parameter_values.append(
                ("connection__node__node", _obj_list, "fix_ratio_out_in_connection_flow", 1 - par[3], _alternative)
            )
        elif par[2] == 'transferCap':
            _temp_importer.relationships += [
                ("connection__from_node", [_connection_name, par[1][1]]),
                ("connection__to_node", [_connection_name, par[1][-1]]),
            ]
            _temp_importer.relationship_parameter_values += [
                ("connection__from_node", [_connection_name, par[1][1]], "connection_capacity", par[3], _alternative),
                ("connection__to_node", [_connection_name, par[1][-1]], "connection_capacity", par[3], _alternative),
            ]
        elif par[2] == 'transferCapBidirectional':
            for _direction in ["from_node", "to_node"]:
                relationship_class = f"connection__{_direction}"
                _obj_list = [_connection_name, par[1][1]]
                _temp_importer.relationships += [
                    (relationship_class, [_connection_name, par[1][1]]),
                    (relationship_class, [_connection_name, par[1][-1]]),
                ]
                _temp_importer.relationship_parameter_values += [
                    (relationship_class, [_connection_name, par[1][1]], "connection_capacity", par[3], _alternative),
                    (relationship_class, [_connection_name, par[1][-1]], "connection_capacity", par[3], _alternative),
                ]

    return _temp_importer
